<?php

/**
 * @file
 * The Serial module main file.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\field\Entity\FieldConfig;

/**
 * Implements hook_help().
 */
function serial_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.serial':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Defines serial field type.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_field_formatter_info_alter().
 */
// Function serial_field_formatter_info_alter(array &$info) {.
//  @todo Review integer / number + SerialItem annotation.
//  $info['text_default']['field_types'][] = SerialStorageInterface::SERIAL_FIELD_TYPE;
// }.
/**
 * Implements hook_ENTITY_TYPE_create().
 *
 * For "field_config".
 */

function serial_field_config_create(FieldConfig $field) {
  if ($field->getType() == 'serial' && !$field->isSyncing() && !$field->isDeleted()) {
    // Create the assistant storage.
    /** @var SerialStorageInterface */
    $serialStorage = \Drupal::getContainer()->get('serial.sql_storage');
    $storageName = $serialStorage->createStorageName(
      $field->getTargetEntityTypeId(),
      $field->getTargetBundle(),
      $field->getFieldStorageDefinition()->getName()
    );
    $serialStorage->createStorageFromName($storageName);

    // Set serial values for old objects.
    $oldCount = $serialStorage->initOldEntries(
      $field->getTargetEntityTypeId(),
      $field->getTargetBundle(),
      $field->getFieldStorageDefinition()->getName()
    );

    if ($oldCount > 0) {
      drupal_set_message(t('Serial values have been automatically set for %count existing entities.', array(
        '%count' => $oldCount,
      )));
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 *
 * For "field_config".
 */
function serial_field_config_delete(FieldConfig $field) {
  if ($field->getType() == 'serial') {
    drupal_set_message('serial_field_config_delete');
    $serialStorage = \Drupal::getContainer()->get('serial.sql_storage');
    $storageName = $serialStorage->createStorageName(
      $field->getTargetEntityTypeId(),
      $field->getTargetBundle(),
      $field->getFieldStorageDefinition()->getName()
    );
    $serialStorage->dropStorageFromName($storageName);
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * For "field_config".
 */
// Function serial_field_config_update(FieldConfig $field) {
//  if ($field->getType() == 'serial') {
//    // @todo this hook could be used to notify the user about the incidence
//    // of setting the field as translatable.
//  }
// }
// **
// * Implements hook_clone_node_alter().
// */
// function serial_clone_node_alter(stdClass $node) {
//  // Reset values of all serial fields when cloning a node.
//  foreach (field_info_instances('node', $node->type) as $field_name => $instance) {
//    $info = field_info_field($field_name);
//
//    if ('serial' === $info['type']) {
//      $node->{$field_name} = array();
//    }
//  }
// }
/**
 * Implements hook_theme().
 */

function serial_theme() {
  // Register the theme for the serial default.
  return array('serial_default' => array('variables' => array('serial_id' => NULL)));
}

/**
 * Theme function for the serial default.
 *
 * @param array $variables
 *
 * @return mixed
 */
function theme_serial_default(array $variables) {
  return $variables['serial_id'];
}
